// Code generated by go-swagger; DO NOT EDIT.

package ip_a_m

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"net/http"
	"time"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	cr "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"
)

// NewPostIPAMIpsParams creates a new PostIPAMIpsParams object
// with the default values initialized.
func NewPostIPAMIpsParams() *PostIPAMIpsParams {
	var ()
	return &PostIPAMIpsParams{

		timeout: cr.DefaultTimeout,
	}
}

// NewPostIPAMIpsParamsWithTimeout creates a new PostIPAMIpsParams object
// with the default values initialized, and the ability to set a timeout on a request
func NewPostIPAMIpsParamsWithTimeout(timeout time.Duration) *PostIPAMIpsParams {
	var ()
	return &PostIPAMIpsParams{

		timeout: timeout,
	}
}

// NewPostIPAMIpsParamsWithContext creates a new PostIPAMIpsParams object
// with the default values initialized, and the ability to set a context for a request
func NewPostIPAMIpsParamsWithContext(ctx context.Context) *PostIPAMIpsParams {
	var ()
	return &PostIPAMIpsParams{

		Context: ctx,
	}
}

// NewPostIPAMIpsParamsWithHTTPClient creates a new PostIPAMIpsParams object
// with the default values initialized, and the ability to set a custom HTTPClient for a request
func NewPostIPAMIpsParamsWithHTTPClient(client *http.Client) *PostIPAMIpsParams {
	var ()
	return &PostIPAMIpsParams{
		HTTPClient: client,
	}
}

/*PostIPAMIpsParams contains all the parameters to send to the API endpoint
for the post IP a m ips operation typically these are written to a http.Request
*/
type PostIPAMIpsParams struct {

	/*Available*/
	Available *string
	/*ClearAll
	  If yes - then IP is marked as available and device and mac address associations are cleared. Also notes and label fields are cleared. Added in v5.7.2

	*/
	ClearAll *string
	/*Device
	  device name, can be new or existing

	*/
	Device *string
	/*Ipaddress
	  If a matching IP address is found, it will update the first matched IP address(unless you specify a vrf_group or vrf_group_id, then it matches or adds IP to that VRF group)

	*/
	Ipaddress string
	/*Label
	  label for the interface (tag still works for backward compatibility)

	*/
	Label *string
	/*Macaddress
	  MAC address â€“ can be new or existing

	*/
	Macaddress *string
	/*Notes
	  Any additional notes

	*/
	Notes *string
	/*Subnet
	  name of the subnet you want to add the IP to. Must be unique. The reason it must be unique is to handle overlapping subnet ranges. The unique name enable selection of the correct subnet. Ignored if vrf_group_id or vrf_group is present in the arguments. Works only when adding a new IP. For existing IPs, use VRF group parameters.

	*/
	Subnet *string
	/*Tags
	  Update IP address tags (note, different than the antiquated tag endpoint. See label parameter above)

	*/
	Tags *string
	/*Type*/
	Type *string
	/*VrfGroup
	  VRF group name

	*/
	VrfGroup *string
	/*VrfGroupID
	  ID of the VRF group

	*/
	VrfGroupID *string

	timeout    time.Duration
	Context    context.Context
	HTTPClient *http.Client
}

// WithTimeout adds the timeout to the post IP a m ips params
func (o *PostIPAMIpsParams) WithTimeout(timeout time.Duration) *PostIPAMIpsParams {
	o.SetTimeout(timeout)
	return o
}

// SetTimeout adds the timeout to the post IP a m ips params
func (o *PostIPAMIpsParams) SetTimeout(timeout time.Duration) {
	o.timeout = timeout
}

// WithContext adds the context to the post IP a m ips params
func (o *PostIPAMIpsParams) WithContext(ctx context.Context) *PostIPAMIpsParams {
	o.SetContext(ctx)
	return o
}

// SetContext adds the context to the post IP a m ips params
func (o *PostIPAMIpsParams) SetContext(ctx context.Context) {
	o.Context = ctx
}

// WithHTTPClient adds the HTTPClient to the post IP a m ips params
func (o *PostIPAMIpsParams) WithHTTPClient(client *http.Client) *PostIPAMIpsParams {
	o.SetHTTPClient(client)
	return o
}

// SetHTTPClient adds the HTTPClient to the post IP a m ips params
func (o *PostIPAMIpsParams) SetHTTPClient(client *http.Client) {
	o.HTTPClient = client
}

// WithAvailable adds the available to the post IP a m ips params
func (o *PostIPAMIpsParams) WithAvailable(available *string) *PostIPAMIpsParams {
	o.SetAvailable(available)
	return o
}

// SetAvailable adds the available to the post IP a m ips params
func (o *PostIPAMIpsParams) SetAvailable(available *string) {
	o.Available = available
}

// WithClearAll adds the clearAll to the post IP a m ips params
func (o *PostIPAMIpsParams) WithClearAll(clearAll *string) *PostIPAMIpsParams {
	o.SetClearAll(clearAll)
	return o
}

// SetClearAll adds the clearAll to the post IP a m ips params
func (o *PostIPAMIpsParams) SetClearAll(clearAll *string) {
	o.ClearAll = clearAll
}

// WithDevice adds the device to the post IP a m ips params
func (o *PostIPAMIpsParams) WithDevice(device *string) *PostIPAMIpsParams {
	o.SetDevice(device)
	return o
}

// SetDevice adds the device to the post IP a m ips params
func (o *PostIPAMIpsParams) SetDevice(device *string) {
	o.Device = device
}

// WithIpaddress adds the ipaddress to the post IP a m ips params
func (o *PostIPAMIpsParams) WithIpaddress(ipaddress string) *PostIPAMIpsParams {
	o.SetIpaddress(ipaddress)
	return o
}

// SetIpaddress adds the ipaddress to the post IP a m ips params
func (o *PostIPAMIpsParams) SetIpaddress(ipaddress string) {
	o.Ipaddress = ipaddress
}

// WithLabel adds the label to the post IP a m ips params
func (o *PostIPAMIpsParams) WithLabel(label *string) *PostIPAMIpsParams {
	o.SetLabel(label)
	return o
}

// SetLabel adds the label to the post IP a m ips params
func (o *PostIPAMIpsParams) SetLabel(label *string) {
	o.Label = label
}

// WithMacaddress adds the macaddress to the post IP a m ips params
func (o *PostIPAMIpsParams) WithMacaddress(macaddress *string) *PostIPAMIpsParams {
	o.SetMacaddress(macaddress)
	return o
}

// SetMacaddress adds the macaddress to the post IP a m ips params
func (o *PostIPAMIpsParams) SetMacaddress(macaddress *string) {
	o.Macaddress = macaddress
}

// WithNotes adds the notes to the post IP a m ips params
func (o *PostIPAMIpsParams) WithNotes(notes *string) *PostIPAMIpsParams {
	o.SetNotes(notes)
	return o
}

// SetNotes adds the notes to the post IP a m ips params
func (o *PostIPAMIpsParams) SetNotes(notes *string) {
	o.Notes = notes
}

// WithSubnet adds the subnet to the post IP a m ips params
func (o *PostIPAMIpsParams) WithSubnet(subnet *string) *PostIPAMIpsParams {
	o.SetSubnet(subnet)
	return o
}

// SetSubnet adds the subnet to the post IP a m ips params
func (o *PostIPAMIpsParams) SetSubnet(subnet *string) {
	o.Subnet = subnet
}

// WithTags adds the tags to the post IP a m ips params
func (o *PostIPAMIpsParams) WithTags(tags *string) *PostIPAMIpsParams {
	o.SetTags(tags)
	return o
}

// SetTags adds the tags to the post IP a m ips params
func (o *PostIPAMIpsParams) SetTags(tags *string) {
	o.Tags = tags
}

// WithType adds the typeVar to the post IP a m ips params
func (o *PostIPAMIpsParams) WithType(typeVar *string) *PostIPAMIpsParams {
	o.SetType(typeVar)
	return o
}

// SetType adds the type to the post IP a m ips params
func (o *PostIPAMIpsParams) SetType(typeVar *string) {
	o.Type = typeVar
}

// WithVrfGroup adds the vrfGroup to the post IP a m ips params
func (o *PostIPAMIpsParams) WithVrfGroup(vrfGroup *string) *PostIPAMIpsParams {
	o.SetVrfGroup(vrfGroup)
	return o
}

// SetVrfGroup adds the vrfGroup to the post IP a m ips params
func (o *PostIPAMIpsParams) SetVrfGroup(vrfGroup *string) {
	o.VrfGroup = vrfGroup
}

// WithVrfGroupID adds the vrfGroupID to the post IP a m ips params
func (o *PostIPAMIpsParams) WithVrfGroupID(vrfGroupID *string) *PostIPAMIpsParams {
	o.SetVrfGroupID(vrfGroupID)
	return o
}

// SetVrfGroupID adds the vrfGroupId to the post IP a m ips params
func (o *PostIPAMIpsParams) SetVrfGroupID(vrfGroupID *string) {
	o.VrfGroupID = vrfGroupID
}

// WriteToRequest writes these params to a swagger request
func (o *PostIPAMIpsParams) WriteToRequest(r runtime.ClientRequest, reg strfmt.Registry) error {

	if err := r.SetTimeout(o.timeout); err != nil {
		return err
	}
	var res []error

	if o.Available != nil {

		// form param available
		var frAvailable string
		if o.Available != nil {
			frAvailable = *o.Available
		}
		fAvailable := frAvailable
		if fAvailable != "" {
			if err := r.SetFormParam("available", fAvailable); err != nil {
				return err
			}
		}

	}

	if o.ClearAll != nil {

		// form param clear_all
		var frClearAll string
		if o.ClearAll != nil {
			frClearAll = *o.ClearAll
		}
		fClearAll := frClearAll
		if fClearAll != "" {
			if err := r.SetFormParam("clear_all", fClearAll); err != nil {
				return err
			}
		}

	}

	if o.Device != nil {

		// form param device
		var frDevice string
		if o.Device != nil {
			frDevice = *o.Device
		}
		fDevice := frDevice
		if fDevice != "" {
			if err := r.SetFormParam("device", fDevice); err != nil {
				return err
			}
		}

	}

	// form param ipaddress
	frIpaddress := o.Ipaddress
	fIpaddress := frIpaddress
	if fIpaddress != "" {
		if err := r.SetFormParam("ipaddress", fIpaddress); err != nil {
			return err
		}
	}

	if o.Label != nil {

		// form param label
		var frLabel string
		if o.Label != nil {
			frLabel = *o.Label
		}
		fLabel := frLabel
		if fLabel != "" {
			if err := r.SetFormParam("label", fLabel); err != nil {
				return err
			}
		}

	}

	if o.Macaddress != nil {

		// form param macaddress
		var frMacaddress string
		if o.Macaddress != nil {
			frMacaddress = *o.Macaddress
		}
		fMacaddress := frMacaddress
		if fMacaddress != "" {
			if err := r.SetFormParam("macaddress", fMacaddress); err != nil {
				return err
			}
		}

	}

	if o.Notes != nil {

		// form param notes
		var frNotes string
		if o.Notes != nil {
			frNotes = *o.Notes
		}
		fNotes := frNotes
		if fNotes != "" {
			if err := r.SetFormParam("notes", fNotes); err != nil {
				return err
			}
		}

	}

	if o.Subnet != nil {

		// form param subnet
		var frSubnet string
		if o.Subnet != nil {
			frSubnet = *o.Subnet
		}
		fSubnet := frSubnet
		if fSubnet != "" {
			if err := r.SetFormParam("subnet", fSubnet); err != nil {
				return err
			}
		}

	}

	if o.Tags != nil {

		// form param tags
		var frTags string
		if o.Tags != nil {
			frTags = *o.Tags
		}
		fTags := frTags
		if fTags != "" {
			if err := r.SetFormParam("tags", fTags); err != nil {
				return err
			}
		}

	}

	if o.Type != nil {

		// form param type
		var frType string
		if o.Type != nil {
			frType = *o.Type
		}
		fType := frType
		if fType != "" {
			if err := r.SetFormParam("type", fType); err != nil {
				return err
			}
		}

	}

	if o.VrfGroup != nil {

		// form param vrf_group
		var frVrfGroup string
		if o.VrfGroup != nil {
			frVrfGroup = *o.VrfGroup
		}
		fVrfGroup := frVrfGroup
		if fVrfGroup != "" {
			if err := r.SetFormParam("vrf_group", fVrfGroup); err != nil {
				return err
			}
		}

	}

	if o.VrfGroupID != nil {

		// form param vrf_group_id
		var frVrfGroupID string
		if o.VrfGroupID != nil {
			frVrfGroupID = *o.VrfGroupID
		}
		fVrfGroupID := frVrfGroupID
		if fVrfGroupID != "" {
			if err := r.SetFormParam("vrf_group_id", fVrfGroupID); err != nil {
				return err
			}
		}

	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}
